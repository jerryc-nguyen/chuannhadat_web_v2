# React Components Re-render Issue: Map Markers Disappearing

## ğŸ¯ The Problem

When clicking on map markers, all other markers would disappear/blink. This is a **common React performance issue** that many developers encounter.

## ğŸ” Root Cause Analysis

### What Was Happening:

1. **User clicks marker** â†’ State changes in Jotai atom
2. **Component re-renders** â†’ All hooks get fresh function references
3. **useResizeImage hook** â†’ Returns new `buildThumbnailUrl` function reference
4. **useMapInteractionHook** â†’ Detects dependency change and re-initializes
5. **Cleanup function runs** â†’ Removes all markers from map
6. **New markers created** â†’ But timing issues cause them to appear missing

### The Dependency Chain:

```typescript
// âŒ PROBLEMATIC CODE
const { buildThumbnailUrl } = useResizeImage(); // New function reference every render

const handleMapMoveEnd = useCallback(async () => {
  // ... marker logic
}, [map, buildThumbnailUrl]); // ğŸš¨ This causes re-initialization!

useEffect(() => {
  // Subscribe to map events
  return () => {
    // ğŸš¨ CLEANUP: Removes all markers when hook re-initializes
    if (markersLayerRef.current) {
      map.removeLayer(markersLayerRef.current);
    }
  };
}, [map, handleMapMoveEnd]); // handleMapMoveEnd changes â†’ cleanup runs
```

## ğŸ› ï¸ The Solution

### Standard React Optimization Pattern:

```typescript
// âœ… FIXED CODE
const { buildThumbnailUrl } = useResizeImage(); // Still gets fresh function

const handleMapMoveEnd = useCallback(async () => {
  // buildThumbnailUrl is still accessible and fresh here
}, [map]); // ğŸ¯ Removed buildThumbnailUrl from dependencies

useEffect(() => {
  // Only re-initializes when map actually changes
  return () => {
    // Cleanup only runs when truly necessary
  };
}, [map, handleMapMoveEnd]); // Much more stable
```

## ğŸ“š Key Learning Points for Beginners

### 1. **Function References in React**

```javascript
// Every render creates new functions
const MyComponent = () => {
  const handleClick = () => {}; // ğŸš¨ New function every render

  // This causes child components to re-render unnecessarily
  return <Child onClick={handleClick} />;
};

// Solution: useCallback for stable references
const MyComponent = () => {
  const handleClick = useCallback(() => {}, []); // âœ… Stable reference
  return <Child onClick={handleClick} />;
};
```

### 2. **Dependency Arrays Matter**

```javascript
// âŒ Over-dependencies cause unnecessary re-runs
useEffect(() => {
  // Some effect
}, [value1, value2, functionThatChangesEveryRender]);

// âœ… Only include what actually matters
useEffect(() => {
  // functionThatChangesEveryRender is still accessible
  // but doesn't trigger re-runs
}, [value1, value2]);
```

### 3. **When Functions Don't Need to be Dependencies**

```javascript
const MyComponent = () => {
  const { someFunction } = useCustomHook(); // Changes every render

  useEffect(() => {
    // someFunction is fresh and works fine here
    someFunction();
  }, []); // âœ… Don't include someFunction if it doesn't need to trigger re-runs
};
```

## ğŸ·ï¸ Issue Classification

### **Type: STANDARD React Performance Issue**

- âœ… Very common in React applications
- âœ… Happens with custom hooks that return functions
- âœ… Classic dependency array optimization problem
- âœ… Well-documented pattern in React community

### **Difficulty Level: Intermediate**

- **For Beginners**: Tricky to debug (effects seem unrelated to cause)
- **For Experienced**: Standard optimization pattern
- **Detection**: Requires understanding React's re-render cycle

## ğŸ”§ Standard Solutions & Patterns

### 1. **Remove Unnecessary Dependencies**

```javascript
// If the function is always fresh and doesn't need to trigger re-runs
useEffect(() => {
  freshFunction(); // Still works!
}, []); // Remove freshFunction from deps
```

### 2. **Use useCallback for Stable References**

```javascript
const stableFunction = useCallback(originalFunction, [realDependencies]);
```

### 3. **Use useRef for Mutable References**

```javascript
const functionRef = useRef();
functionRef.current = freshFunction; // Always up to date

useEffect(() => {
  functionRef.current(); // Always calls latest version
}, []); // No dependencies needed
```

### 4. **Memoize Hook Results**

```javascript
const { expensiveFunction } = useCustomHook();
const memoizedFunction = useMemo(
  () => expensiveFunction,
  [
    /* real deps */
  ],
);
```

## ğŸ¯ Prevention Tips

### **For Hook Authors:**

```javascript
// âœ… Return stable references when possible
export const useMyHook = () => {
  const stableFunction = useCallback((params) => {
    // implementation
  }, []); // Stable if no dependencies

  return { stableFunction };
};
```

### **For Hook Consumers:**

```javascript
// âœ… Be selective with dependencies
const { someFunction } = useMyHook();

useEffect(() => {
  someFunction(); // Fresh function, works fine
}, []); // Don't include someFunction unless it needs to trigger re-runs
```

## â“ Why Functions in Dependencies? (Common Confusion)

### **The React Rule: "Include everything you use from component scope"**

```javascript
const MyComponent = ({ userId }) => {
  const [data, setData] = useState(null);

  // This function captures userId from props
  const fetchUserData = () => {
    api.getUser(userId).then(setData);
  };

  useEffect(() => {
    fetchUserData(); // Uses function from component scope
  }, [fetchUserData]); // â“ Why include the function?

  return <div>{data?.name}</div>;
};
```

### **The Problem: Stale Closures**

```javascript
// âŒ DANGEROUS: Missing function dependency
const MyComponent = ({ userId }) => {
  const fetchUserData = () => {
    api.getUser(userId).then(setData); // userId might be stale!
  };

  useEffect(() => {
    fetchUserData();
  }, []); // Missing fetchUserData dependency

  // When userId changes from 1 to 2:
  // - Component re-renders with new userId (2)
  // - fetchUserData gets new userId (2)
  // - But useEffect doesn't re-run (empty deps)
  // - Still using old fetchUserData that captures userId (1)
  // - Fetches wrong user data!
};
```

### **When Functions DON'T Need Dependencies**

#### **1. Functions that don't capture component values:**

```javascript
// âœ… No dependency needed - function doesn't use component values
const MyComponent = () => {
  const { apiCall } = useExternalHook(); // External function

  useEffect(() => {
    apiCall(); // Doesn't capture anything from component
  }, []); // Safe to omit apiCall
};
```

#### **2. Functions that are always fresh but don't need to trigger re-runs:**

```javascript
// âœ… Our map case - function is fresh but doesn't need to trigger effects
const MyComponent = () => {
  const { buildThumbnailUrl } = useResizeImage(); // Always fresh

  useEffect(() => {
    // buildThumbnailUrl is always the latest version
    // But we don't want to re-run effect when it changes
    const processMarkers = () => {
      markers.forEach((marker) => {
        const url = buildThumbnailUrl(marker.image); // Always works
      });
    };
  }, []); // Intentionally omit buildThumbnailUrl
};
```

#### **3. Stable functions (useCallback with empty deps):**

```javascript
// âœ… Stable function doesn't need dependency
const MyComponent = () => {
  const stableFunction = useCallback(() => {
    // No dependencies from component scope
  }, []);

  useEffect(() => {
    stableFunction();
  }, []); // Safe - function never changes
};
```

### **When Functions DO Need Dependencies**

#### **1. Functions that capture changing values:**

```javascript
// âœ… Function captures userId - needs dependency
const MyComponent = ({ userId }) => {
  const fetchUser = () => {
    api.getUser(userId); // Captures userId
  };

  useEffect(() => {
    fetchUser();
  }, [fetchUser]); // Must include - userId might change
};
```

#### **2. Functions that should trigger re-runs:**

```javascript
// âœ… Want to re-run when validation logic changes
const MyComponent = ({ validationRules }) => {
  const validateData = (data) => {
    return validationRules.every((rule) => rule(data));
  };

  useEffect(() => {
    const isValid = validateData(currentData);
    setIsValid(isValid);
  }, [validateData]); // Re-validate when validation logic changes
};
```

## ğŸš¨ Common Mistakes

1. **Blindly following ESLint exhaustive-deps rule** (sometimes you know better)
2. **Not understanding when functions actually need to trigger re-runs**
3. **Including functions that don't capture component values**
4. **Over-memoizing everything** (performance overhead)
5. **Not using React DevTools Profiler** to identify re-render causes

## ğŸ† Best Practices

1. **Measure first** - Use React DevTools to identify actual performance issues
2. **Be selective** - Only optimize when there's a real problem
3. **Understand the trade-offs** - Memoization has its own costs
4. **Test thoroughly** - Ensure optimizations don't break functionality
5. **Document why** - Explain why certain dependencies are omitted

---

## ğŸ’¡ Key Takeaway

> **The function reference changing every render is normal React behavior. The key is understanding when that change should trigger side effects and when it shouldn't.**

This is a **standard React optimization pattern** that every React developer should understand. The solution is **well-established** and **widely used** in the React community.
